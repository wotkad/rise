const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const BUILD_DIR = path.resolve(__dirname, '../../build');
const SW_FILE = path.resolve(BUILD_DIR, 'service-worker.js');
const OFFLINE_FILE = path.resolve(BUILD_DIR, 'offline.html');

// ===== 1. –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –∏–∑ /build =====
function getAllFiles(dir, prefix = '/') {
  let results = [];
  const list = fs.readdirSync(dir);
  list.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat && stat.isDirectory()) {
      results = results.concat(getAllFiles(filePath, path.join(prefix, file)));
    } else {
      // –∏—Å–∫–ª—é—á–∞–µ–º —Å–ª—É–∂–µ–±–Ω—ã–µ —Ñ–∞–π–ª—ã
      if (
        file === '.DS_Store' ||
        filePath.endsWith('service-worker.js')
      ) return;

      results.push(path.join(prefix, file));
    }
  });
  return results;
}

const files = getAllFiles(BUILD_DIR);


// ===== 0. –ü—Ä–æ–≤–µ—Ä—è–µ–º offline.html =====
if (!fs.existsSync(OFFLINE_FILE)) {

  const cachedPagesRows = files
    .filter(f => f.endsWith('.html'))
    .map(f => `<tr class="border-b border-gray-700 hover:bg-gray-700 transition-colors duration-300"><td class="px-4 py-2"><a href="${f}" class="text-blue-400 hover:underline">${f}</a></td></tr>`)
    .join('\n');

  fs.writeFileSync(
    OFFLINE_FILE,
    `<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–í—ã –æ—Ñ–ª–∞–π–Ω</title>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white text-center p-4">
  <main class="max-w-xl w-full">
    <h1 class="text-3xl font-bold mb-4">–í—ã –æ—Ñ–ª–∞–π–Ω</h1>
    <p class="mb-4 text-gray-400">–ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.</p>
    <button 
      onclick="window.location.reload()" 
      class="px-6 py-2 mb-10 bg-blue-600 rounded hover:bg-blue-500 transition-colors duration-300">
      –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
    </button>
    
    <h2 class="text-xl font-semibold mb-4">–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–∑ –∫–µ—à–∞:</h2>
    <div class="overflow-x-auto">
      <table class="w-full text-left border border-gray-700">
        <thead>
          <tr class="bg-gray-800">
            <th class="px-4 py-2">–°—Ç—Ä–∞–Ω–∏—Ü–∞</th>
          </tr>
        </thead>
        <tbody>
          ${cachedPagesRows}
        </tbody>
      </table>
    </div>
  </main>
</body>
</html>`
  );

  // console.log('‚úÖ offline.html —Å–æ–∑–¥–∞–Ω');
}

// ===== 2. –°–æ–∑–¥–∞—ë–º —Ö—ç—à –≤–µ—Ä—Å–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ —Ñ–∞–π–ª–æ–≤ =====
const hash = crypto
  .createHash('sha256')
  .update(files.map(f => fs.readFileSync(path.join(BUILD_DIR, f))).join(''))
  .digest('hex')
  .substring(0, 12);

const CACHE_NAME = `${hash}`;

// console.log(`üß© –°–æ–∑–¥–∞–Ω–∏–µ service worker (${CACHE_NAME})`);
// console.log(`üì¶ –§–∞–π–ª–æ–≤ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∫–µ—à: ${files.length}`);

// ===== 3. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ SW =====
const swContent = `
// ===== Auto-generated by generate-sw.js =====
const CACHE_NAME = '${CACHE_NAME}';
const STATIC_ASSETS = ${JSON.stringify(files, null, 2)};
const DATO_ENDPOINT = 'https://graphql.datocms.com/';
const TTL = 10 * 60 * 1000; // 10 –º–∏–Ω—É—Ç

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[ServiceWorker] Caching', STATIC_ASSETS.length, 'files');
      return cache.addAll(STATIC_ASSETS);
    })
  );
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) => 
      Promise.all(
        keys
          .filter((key) => key !== CACHE_NAME)
          .map((key) => {
            console.log('[ServiceWorker] –°—Ç–∞—Ä—ã–π –∫–µ—à —É–¥–∞–ª—ë–Ω', key);
            return caches.delete(key);
          })
      )
    )
  );
  self.clients.claim();
});

self.addEventListener('fetch', (event) => {
  if (event.request.method !== 'GET') return;

  const requestUrl = new URL(event.request.url);

  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º Barba –∏–ª–∏ API
  if (requestUrl.searchParams.has('barba') || requestUrl.pathname.startsWith('/api/')) {
    return;
  }

  // 1Ô∏è‚É£ ‚Äî DatoCMS GraphQL API —Å TTL
  if (requestUrl.href === DATO_ENDPOINT) {
    event.respondWith(handleDatoCMSRequest(event));
    return;
  }

  // 2Ô∏è‚É£ ‚Äî HTML (Barba)
  if (event.request.headers.get('accept')?.includes('text/html')) {
    event.respondWith(networkFirst(event.request));
    return;
  }

  // 3Ô∏è‚É£ ‚Äî –°—Ç–∞—Ç–∏–∫–∞ (Cache First)
  event.respondWith(cacheFirst(event.request));
});

// === Cache-first –¥–ª—è —Å—Ç–∞—Ç–∏–∫–∏ ===
async function cacheFirst(request) {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);
  if (cached) return cached;

  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (err) {
    console.warn('[SW] Cache-first failed', err);
    return cached;
  }
}

// === Network-first –¥–ª—è HTML —Å—Ç—Ä–∞–Ω–∏—Ü (Barba) ===
async function networkFirst(request) {
  const cache = await caches.open(CACHE_NAME);
  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (err) {
    const cached = await cache.match(request);
    return cached || caches.match('/offline.html');
  }
}

// === DatoCMS Cache-first —Å TTL –∏ fallback ===
async function handleDatoCMSRequest(event) {
  const cloned = event.request.clone();
  const body = await cloned.text();

  // —Å–æ–∑–¥–∞—ë–º —Ö—ç—à —Ç–µ–ª–∞ GraphQL-–∑–∞–ø—Ä–æ—Å–∞
  const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(body));
  const hashHex = Array.from(new Uint8Array(hashBuffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');

  const cacheKey = new Request(\`\${DATO_ENDPOINT}?cache=\${hashHex}\`);
  const cache = await caches.open(CACHE_NAME);
  const cachedResponse = await cache.match(cacheKey);
  const now = Date.now();

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º TTL
  if (cachedResponse) {
    const fetchedAt = cachedResponse.headers.get('sw-fetched-at');
    if (fetchedAt && now - new Date(fetchedAt).getTime() < TTL) {
      return cachedResponse;
    }
  }

  try {
    const networkResponse = await fetch(event.request.clone());
    const headers = new Headers(networkResponse.headers);
    headers.append('sw-fetched-at', new Date().toISOString());
    const responseToCache = new Response(await networkResponse.clone().blob(), { headers });

    await cache.put(cacheKey, responseToCache.clone());
    return networkResponse;
  } catch (err) {
    if (cachedResponse) return cachedResponse;
    return new Response(JSON.stringify({ error: 'offline', message: 'No network and no cache' }), {
      headers: { 'Content-Type': 'application/json' },
      status: 503,
    });
  }
}
`;

// ===== 4. –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ñ–∞–π–ª =====
fs.writeFileSync(SW_FILE, swContent);
console.log(`‚úÖ –ì–æ—Ç–æ–≤–æ: service worker —Å–æ–∑–¥–∞–Ω (—Ñ–∞–π–ª–æ–≤ –≤ –∫–µ—à–µ: ${files.length})`);
